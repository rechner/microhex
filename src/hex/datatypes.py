import string
import struct
import collections
import itertools
import ctypes
import sys
import copy
import hex.utils as utils
import hex.encodings as encodings
from PyQt4.QtCore import QAbstractItemModel, QModelIndex, Qt, pyqtSignal
from PyQt4.QtGui import QWidget, QComboBox, QFormLayout, QSpinBox, QTreeView, QVBoxLayout, QIcon, QLineEdit, QFrame


class TemplateNotFoundError(Exception):
    pass


class DecodeError(Exception):
    def __init__(self, desc, value=None):
        Exception.__init__(self, desc)
        self.value = value


LittleEndian, BigEndian = range(2)


"""
This module is for encoding and decoding binary data. Functionality is based on the following classes:
    - Template classes. Derived from AbstractTemplate base class.
      Represents template for binary data format encoder/decoder. There is template class for all binary format classes
      Microhex can parse (numbers, strings, enumerations, structures). Each template can have set of parameters (for
      example, template for zero-terminated string has character encoding as its parameter, and template that parses
      32-bit width integers has parameters that determine endianess and presence of sign). Parameters' values are
      stored in object of InstantiateContext class. So:
        type template + context = instantiated template = type.
      All structures share same template of class Structure.
    - InstantiateContext class.
      Objects of this class contain values for adjustable parameters of template.
    - InstantiatedTemplate class.
      Holds references to template and instantiate context.
    - Value class.
      Objects of this class are returned by decoding methods. Contains information about decoded value, data used to
      decode it, meta-information, etc.
"""


class Value(object):
    """Objects of this class are returned by decoding methods. Contains information about decoded value, data used to
    decode it, meta-information, etc.
    .decodeStatus: determines if decoding was successful. Depending on value of this attribute, value
    of .decodeStatusText can be either comment generated by decoder or warning or error message. Note that even if
    decoder fails to properly decode data, it should provide as much information about value as possible (ex:
    structure decoder always preserves structure layout information in .members attribute instead of returning
    'clean' Value object).
    .comment is comment that comes from user or from author of decoder. Comments generated by decoder should be stored
    in .decodeStatusText attribute. You can use .data() method with FormatComment to access value of this attribute.
    .alternativeText contains alternative (human-readable) representation of decoded value. For example, when parsing
    enumeration value, decoder can provide both integer representation of it (.decodedValue) and name of constant
    associated with decoded value (.alternativeText). You can use .data() method with FormatAlternativeText to access
    value of this attribute.
    .members is for complex values like a structures or arrays. Arrays are just like a structures, but with fields
    named as indexes ('0', '1', should be strings).
    .parentValue is used in complex values too. All values in .members dictionary should reference its parent by
    value in .parentValue attribute.
    As decoder always operates on data through cursor, it should store DynamicBufferRange of data that were used to
    decode value. This range object can be either fixed or not. It is not guaranteed that data referred by stored
    range will be always same as data at the moment of decoding, so it is recommended for decoder to encache used data
    in .cachedBufferData attribute (but this recommendation does not install 128-GB RAM module on every user computer,
    so... you had been warned).
    .bufferRange: object of utils.DynamicBufferRange referring to used data. Should not be None, otherwise Value
    should be considered invalid even if .decodeStatus == StatusCorrect.

    You can have quick access to complex value's members with .getMemberValue and .hasMember methods, which allow
    more than one nest level.
    """

    StatusInvalid, StatusWarning, StatusCorrect = range(3)
    FormatData, FormatDecoded, FormatText, FormatAlternativeText, FormatComment, FormatColor = range(6)

    def __init__(self):
        self.instantiatedType = None
        self.bufferRange = None
        self.decodeStatus = self.StatusInvalid
        self.decodeStatusText = ''
        self.comment = ''
        self.alternativeText = ''
        self.members = collections.OrderedDict()
        self.parentValue = None

        self.cachedBufferData = b''
        self.decodedValue = None

    def data(self, fmt=FormatDecoded):
        if fmt == self.FormatData and self.cachedBufferData is not None:
            return self.cachedBufferData
        elif fmt == self.FormatDecoded:
            return self.decodedValue
        elif fmt == self.FormatText:
            return str(self.decodedValue) if self.decodedValue is not None else str(self.alternativeText) or ''
        elif fmt == self.FormatAlternativeText:
            return self.alternativeText
        elif fmt == self.FormatComment:
            return self.comment

    @property
    def valid(self):
        return self.bufferRange is not None and self.decodeStatus != self.StatusInvalid

    @property
    def isComplex(self):
        return bool(self.members)

    @property
    def bufferData(self):
        """Returns data used to decode value. Difference from .data(FormatData) is that .bufferData reads data
        pointed to by .bufferRange if there is no cached data (see note above), while .data method does not.
        """
        if self.cachedBufferData:
            return self.cachedBufferData
        elif self.bufferRange is not None and self.bufferRange.valid:
            return self.bufferRange.document.read(self.bufferRange.startPosition, self.bufferRange.size)
        else:
            return b''

    @staticmethod
    def buildValue(instantiated_type, buffer_range=None, decoded=None):
        result = Value()
        result.instantiatedType = instantiated_type
        result.bufferRange = buffer_range
        result.decodedValue = decoded
        result.decodeStatus = Value.StatusCorrect
        return result

    def getMemberValue(self, name):
        if '.' not in name:
            return self.members.get(name, None)
        else:
            member_value = self.members.get(name[:name.index('.')])
            if member_value is not None:
                return member_value.getMemberValue(name[name.index('.') + 1:])

    def hasMember(self, name):
        if '.' not in name:
            return name in self.members
        else:
            member_value = self.members.get(name[:name.index('.')])
            return member_value is not None and member_value.hasMember(name[name.index('.') + 1:])

    def getFullMemberName(self):
        """If this Value is a member of any other value, returns fully qualified name of this value which can be used
        to access it from top-parent value.
        """
        if self.parentValue is not None:
            name = utils.first(key for key, value in self.parentValue.members.items() if value is self)
            assert(name is not None)
            parent_name = self.parentValue.getFullMemberName()
            return parent_name + '.' + name if parent_name else name
        return ''


class AbstractTemplate:
    """Basic class for all templates. Each template has name (it is not required for it to be unique). Templates
    are organized by TypeManager objects, where all templates reside in namespaces. One template object can live
    only in one TypeManager and TypeManager should not reference one template object twice. Name of template with
    all namespaces is called qualified name of template. If template is not associated with TypeManager, qualifiedName
    is empty. Note that last part of qualified name (type name in TypeManager) can differ from .realName of template.
    Template stores information about properties that can be adjusted by context and default context (contains default
    values for context parameters).
    Objects used as values of context parameters should support equality testing.
    """

    def __init__(self, real_name, adjustable_context_properties=None):
        self.realName = real_name
        self.qualifiedName = ''
        self.typeManager = None
        self.defaultAlignHint = 1  #todo: needs comment
        self.adjustableContextProperties = {'endianess': int, 'ignore_field': bool}
        if adjustable_context_properties is not None:
            self.adjustableContextProperties.update(adjustable_context_properties)
        self.defaultsContext = InstantiateContext()

    def setContextDefaults(self, context):
        """Use this method to set uninitialized context attributes to defaults."""
        context.setDefaults(self.defaultsContext)

    def decode(self, context) -> Value:
        """Should raise DecodeError if something goes wrong while decoding. You still can get Value (broken one) from
        exception class.
        """
        raise NotImplementedError()

    def createLayout(self, value, context):
        pass

    @property
    def fixedSize(self):
        """If decoder always decodes value using fixed number of bytes from buffer, should return number of bytes;
        otherwise returns 0.
        """
        return 0

    #def write(self, context, value, write_method):
    #    raise NotImplementedError()

    def createConfigWidget(self, parent):
        """Configuration widget will be used to set context parameters.
        """
        pass

    def decodeError(self, desc, value):
        if value is None:
            value = Value.buildValue(InstantiatedType(self, InstantiateContext()), None, None)
        value.decodeStatus = Value.StatusInvalid
        value.decodeStatusText = desc
        return DecodeError(desc, value)


class InstantiatedType:
    def __init__(self, template, context):
        self.template = template
        self.context = context


class InstantiateContext(dict):
    def __init__(self, iterable=None, **kwargs):
        dict.__init__(self, iterable or tuple(), **kwargs)
        self['cursor'] = None
        self['endianess'] = LittleEndian
        self['alignHint'] = 0

    def setDefaults(self, dc=None, **defaults):
        if dc is not None:
            for key in dc.keys():
                self.setdefault(key, dc[key])
        for key in defaults.keys():
            self.setdefault(key, defaults[key])


class AbstractFormatTypeTemplate(AbstractTemplate):
    """Decoding based on primitive types parsing from struct module. These types are always fixed size. Subclasses should
    provide implementation of fixedSize and _formatString properties for this class to work.
    """

    def decode(self, context):
        assert(self.fixedSize > 0)
        def_value = Value.buildValue(InstantiatedType(self, context), None, None)

        try:
            data_to_decode = context['cursor'].read(0, self.fixedSize)
            def_value.bufferRange = context['cursor'].bufferRange(0, self.fixedSize)
            def_value.cachedBufferData = data_to_decode
        except IndexError:
            raise self.decodeError(utils.tr('no enough data available'), def_value)

        try:
            unpacked = struct.unpack(self._getFormatString(context), data_to_decode)
            if unpacked is not None:
                def_value.decodedValue = unpacked[0]
                return def_value
            else:
                raise self.decodeError(utils.tr('None result from struct.unpack'), def_value)
        except struct.error as err:
            raise self.decodeError(str(err), def_value)

    def _getFormatString(self, context):
        raise NotImplementedError()

    # def encode(self, value, cursor=None):
    #     if not self.canEncode(value):
    #         return
    #
    #     if isinstance(value, Value):
    #         value = value.decodedValue
    #     if not isinstance(value, Value) and self.canEncode(value):
    #         try:
    #             return struct.pack(self._formatString, value)
    #         except struct.error as err:
    #             err = str(err)
    #
    #         raise ValueError(utils.tr('failed to encode value: {0}').format(err))


class AbstractIntegerTemplate(AbstractFormatTypeTemplate):
    _WidthFormatDict = {1: 'b', 2: 'h', 4: 'i', 8: 'q'}

    def __init__(self, real_name, width, signed):
        if width not in self._WidthFormatDict:
            raise ValueError(utils.tr('integers of width {0} are not supported').format(width))
        AbstractFormatTypeTemplate.__init__(self, real_name)
        self._width = width
        self._signed = bool(signed)
        self.defaultAlignHint = width

    @property
    def fixedSize(self):
        return self._width

    @property
    def maximal(self):
        return (256 ** self._width // (2 if self._signed else 1)) - 1

    @property
    def minimal(self):
        return -self.maximal - 1 if self._signed else 0

    def _getFormatString(self, context):
        width_format = self._WidthFormatDict[self._width]
        return ('<' if context['endianess'] == LittleEndian else '>') + (width_format if self._signed else
                                                                      width_format.upper())

    def createConfigWidget(self, parent):
        return OnlyEndianessConfigWidget(parent, self)

    # def canEncode(self, value):
    #     if isinstance(value, Value):
    #         value = value.decodedValue
    #     return isinstance(value, int) and self.minimal <= value <= self.maximal
    #
    # def parseString(self, text):
    #     try:
    #         return int(text)
    #     except ValueError:
    #         return None


class FloatTemplate(AbstractFormatTypeTemplate):
    @property
    def fixedSize(self):
        return 4

    def __init__(self):
        AbstractFormatTypeTemplate.__init__(self, 'float')
        self.defaultAlignHint = 4

    def _getFormatString(self, context):
        return ('<' if context['endianess'] == LittleEndian else '>') + 'f'

    def createConfigWidget(self, parent):
        return OnlyEndianessConfigWidget(parent, self)

    # def canEncode(self, value):
    #     # unfortunately, struct.pack does not raises any exception when converting too large Python float to
    #     # float and silently replaces its value with inf (or -inf). So encode/decode value and see if it was
    #     # converted to inf.
    #     if isinstance(value, Value):
    #         value = value.decodedValue
    #     if not isinstance(value, float):
    #         return False
    #     if math.isfinite(value):
    #         try:
    #             return math.isfinite(struct.unpack(self._formatString, struct.pack(self._formatString, value)))
    #         except struct.error:
    #             return False
    #     return True
    #
    # def parseString(self, text):
    #     try:
    #         return float(text)
    #     except ValueError:
    #         return None


class DoubleTemplate(AbstractFormatTypeTemplate):
    @property
    def fixedSize(self):
        return 8

    def __init__(self):
        AbstractFormatTypeTemplate.__init__(self, 'double')
        self.defaultAlignHint = 8

    def _getFormatString(self, context):
        return ('<' if context['endianess'] == LittleEndian else '>') + 'd'

    def createConfigWidget(self, parent):
        return OnlyEndianessConfigWidget(parent, self)

    # def canEncode(self, value):
    #     if isinstance(value, Value):
    #         value = value.decodedValue
    #     return isinstance(value, float)


class PaddingBytesTemplate(AbstractTemplate):
    """This template used to represent unused bytes between structure members. You should not try to use it directly
    while building or altering structures to create alignment; use alignment parameters instead.
    Number of padding bytes is controlled with context property named 'size' that cannot be negative. If there is
    no enough bytes in buffer, decoding fails.
    """
    def __init__(self):
        AbstractTemplate.__init__(self, 'padding', {'size': int})

    def setContextDefaults(self, context):
        context.setDefaults(size=0)
        AbstractTemplate.setContextDefaults(self, context)

    def decode(self, context):
        value = Value.buildValue(InstantiatedType(self, context), None, None)

        try:
            size = context.get('size', 0)
            if size < 0:
                raise self.decodeError(utils.tr('padding with negative size ({0})'.format(size)), value)
            data = context['cursor'].read(0, size)
            value.cachedBufferData = data
            value.bufferRange = context['cursor'].bufferRange(0, size)
            value.decodedValue = data
            return value
        except IndexError:
            raise self.decodeError(utils.tr('no enough data available'), value)


class Structure(AbstractTemplate):
    """Represents set of fields with different names, which values are decoded sequentially to get resulting value.
    Important property of Microhex structures is that ones can change its layout and parameters of fields depending
    on values of decoded fields. For example, it is easy to create structure simulating something like Pascal strings
    which consist of string with size determined by first structure field.
    To describe dependency between field value and attribute of another field context you should add object of
    Structure.Link class to structure' context property 'links'. Each Link defines name of field which triggers
    a change (source) and name of context property which will be set to decoded value of field. Both source and
    destination names can be nested (qualified).
    Each field can have an alignment helping to determine how many bytes before it will be unused. Alignment is
    defined by alignment hints stored in field context (field context is context of field template). Alignment hint
    is positive nonzero integer and is equal to alignment granularity (1 granularity means no alignment).
    Template can define its own alignment hint as well as Field can. Alignment hint defined by Field has priority
    over one defined by template. To use alignment hint provided by template, you should set alignment hint of field
    to 0 (default value).

    Context parameters:
    fields: list of fields (each of .Field class)
    links: list of links (each of .Link class)
    linkImpls: list of custom object that react on changes in values of decoded fields (each of .LinkImpl class).

    If field context has 'ignore_field' parameter value set to True, this field will be skipped by decoder.
    """

    class Field:
        def __init__(self, name, template, type_context=None, align_hint=0):
            self.name = name
            self.template = template
            self.typeContext = type_context or InstantiateContext()
            if align_hint > 0:
                self.typeContext['alignHint'] = align_hint

        def setContextPropertyFromValue(self, prop_name, value):
            return self.setContextPropertyFromRawValue(prop_name, value.decodedValue)

        def setContextPropertyFromRawValue(self, prop_name, value):
            """Set one of attributes enumerated in template adjustableContextProperties property. Does type checking.
            Can set nested properties looking for sub-properties in context fields. Returns True if property was
            updated, False otherwise.
            """
            if '.' not in prop_name:
                # set property of this context - check if we have adjustable property with this name and
                # check value type.
                if prop_name not in self.template.adjustableContextProperties:
                    raise ValueError(utils.tr('{0} is not an adjustable context property').format(prop_name))

                required_type = self.template.adjustableContextProperties[prop_name]
                if not isinstance(value, required_type):
                    raise ValueError(utils.tr('while updating context property {0}: type mismatch, value of {1} class '
                                              'provided, but {2} required').format(prop_name, str(type(value)),
                                                                                   str(required_type)))

                if prop_name not in self.typeContext or self.typeContext[prop_name] != value:
                    self.typeContext[prop_name] = value
                    return True
            else:
                # Find field with corresponding name and recursively set property for it.
                subfield_name = prop_name[:prop_name.index('.')]
                field = utils.first(f for f in self.typeContext.get('fields', []) if f.name == subfield_name)
                if field is None:
                    raise ValueError(utils.tr('while updating property {0}: no field named {1}').format(prop_name,
                                                                                                        subfield_name))
                return field.setContextPropertyFromRawValue(prop_name[prop_name.index('.') + 1:], value)
            return False

        def hasProperty(self, prop_name):
            if '.' not in prop_name:
                return prop_name in self.template.adjustableContextProperties
            else:
                subfield_name = prop_name[:prop_name.index('.')]
                subfield = utils.first(f for f in self.typeContext.get('fields', []) if f.name == subfield_name)
                return subfield is not None and subfield.hasProperty(prop_name[prop_name.index('.')+1:])

    class Link:
        def __init__(self, source, destination):
            self.source = source
            self.destination = destination

    class InvalidateField(Exception):
        def __init__(self, updated_link_impl, new_value, field_context):
            self.updatedLinkImpl = updated_link_impl
            self.newValue = new_value
            self.fieldContext = field_context

    class LinkImpl:
        """This is internal class used to update links. After parsing a field, structure calls LinkImpl.update for
        each LinkImpl with sourceFieldName attribute value equal to parsed field name. Typically, LinkImpl.update
        updates dependent attribute of field that has different parent and is not direct or indirect child of decoded
        field.
        """
        def __init__(self, source_field_name, dependent_field, dependent_property, current_field, keeping_context):
            self.sourceFieldName = source_field_name  # name of field this link depends on
            self.dependentField = dependent_field  # Field which property should be updated. Note that this
                                                   # field is in keeping context, not context of structure being parsed.
            self.dependentProperty = dependent_property  # name of property that should be updated
            self.currentField = current_field  # field in keeping context being currently parsing
            self.keepingContext = keeping_context

        @property
        def dependentFieldIndex(self):
            return utils.indexOf(self.keepingContext['fields'], lambda field: field is self.dependentField)

        @property
        def currentFieldIndex(self):
            return utils.indexOf(self.keepingContext['fields'], lambda field: field is self.currentField)

        def update(self, new_value, current_context):
            assert(self.keepingContext is not current_context)
            if self.dependentField.setContextPropertyFromValue(self.dependentProperty, new_value):
                if self.dependentFieldIndex <= self.currentFieldIndex:
                    raise Structure.InvalidateField(self, new_value, current_context)

    def __init__(self):
        AbstractTemplate.__init__(self, 'struct', {'include_padding': bool, 'fields': (list, tuple),
                                                   'links': (list, tuple), 'linkImpls': (list, tuple)})

    def setContextDefaults(self, context):
        context.setDefaults(fields=[], links=[], linkImpls=[])
        AbstractTemplate.setContextDefaults(self, context)

    def decode(self, context):
        result_value = Value.buildValue(InstantiatedType(self, context))
        self.createLayout(result_value, context)

        cursor = context['cursor'].clone()

        stored_cursor_positions = list()
        field_index = 0
        while field_index < len(context['fields']):
            try:
                field = context['fields'][field_index]

                # if we rolled back to field, restore old cursor position
                if field_index < len(stored_cursor_positions):
                    cursor.position = stored_cursor_positions[field_index]

                # store cursor position for this field. We will use it when rolling back to this field
                if field_index >= len(stored_cursor_positions):
                    stored_cursor_positions.append(cursor.position)
                else:
                    stored_cursor_positions[field_index] = cursor.position
                    del stored_cursor_positions[field_index+1:]

                if field.typeContext.get('ignore_field', False):
                    if field.name in result_value.members:
                        del result_value.members[field.name]
                    field_index += 1
                    continue
                elif field.name not in result_value.members:
                    self._createDefaultField(result_value, field)

                field_template = field.template
                if field_template is None:
                    raise self.decodeError(utils.tr('no template for field {0}').format(field.name), result_value)

                type_manager = context['typeManager'] or globalTypeManager()
                field_context = type_manager.prepareContext(field.typeContext, field_template, cursor)

                # determine start position for this field respecting field alignment.
                field_align_hint = field_context['alignHint'] if field_context['alignHint'] > 0 else field_template.defaultAlignHint
                if field_align_hint > 1 and (cursor.position - context['cursor'].position) % field_align_hint:
                    cursor.advance(field_align_hint - ((cursor.position - context['cursor'].position) % field_align_hint))

                # build list of LinkImpls for field context
                # first collect it from our context links
                for link in context['links']:
                    if link.source.startswith(field.name + '.'):
                        # does field that will be parsed can have its own fields?
                        if not isinstance(field.template, Structure):  #todo: just test if template is complex
                            raise self.decodeError(utils.tr('while processing link {0}->{1}: {2} is not a structure')
                                                   .format(link.source, link.destination, field.name),
                                                   result_value)

                        # find field that should react on changes in inner fields of field being parsed
                        dest_field_name = link.destination[:link.destination.index('.')]
                        dest_field = utils.first(field for field in context['fields'] if field.name == dest_field_name)
                        if dest_field is None:
                            raise self.decodeError(utils.tr('while processing link {0}->{1}: no field called {2}')
                                                   .format(link.source, link.destination, dest_field_name),
                                                   result_value)

                        dest_prop = link.destination[link.destination.index('.') + 1:]

                        impl = self.LinkImpl(link.source[link.source.index('.') + 1:], dest_field, dest_prop, field,
                                             context)
                        field_context['linkImpls'].append(impl)

                # second, find LinkImpls that should be transferred to field
                for link_impl in context['linkImpls']:
                    if link_impl.sourceFieldName.startswith(field.name + '.'):
                        # copy this impl, but adjust sourceFieldName - remove field name
                        cloned_impl = copy.copy(link_impl)
                        cloned_impl.sourceFieldName = link_impl.sourceFieldName[link_impl.sourceFieldName.index('.')+1:]
                        field_context['linkImpls'].append(cloned_impl)

                # decode field value
                try:
                    field_value = field_template.decode(field_context)
                    field_value.parentValue = result_value
                except DecodeError as err:
                    err.value.parentValue = result_value
                    result_value.members[field.name] = err.value
                    raise self.decodeError(utils.tr('while decoding field "{0}": {1}').format(field.name, str(err)),
                                           result_value)

                impls = context['linkImpls'][:]
                # find links that should be updated and add them to impls list
                for link in context['links']:
                    if link.source == field.name:
                        dest_field_name = link.destination[:link.destination.index('.')]
                        dest_field = utils.first(field for field in context['fields'] if field.name == dest_field_name)
                        dest_prop = link.destination[link.destination.index('.') + 1:]
                        impls.append(self.LinkImpl(link.source, dest_field, dest_prop, field, context))

                # now find links that should be updated with decoded value of this field
                for link_impl in impls:
                    if link_impl.sourceFieldName == field.name:
                        link_impl.update(field_value, field_context)

                result_value.members[field.name] = field_value

                cursor.advance(field_value.bufferRange.size)
                field_index += 1
            except self.InvalidateField as inv_field:
                if inv_field.updatedLinkImpl.keepingContext is context:
                    field_index = inv_field.updatedLinkImpl.dependentFieldIndex
                    continue
                else:
                    raise

        result_value.bufferRange = context['cursor'].bufferRange(0, cursor.position - context['cursor'].position)
        return result_value

    def createLayout(self, value, context):
        for field in context.get('fields', ()):
            self._createDefaultField(value, field)

    def _createDefaultField(self, value, field):
        field_value = Value.buildValue(InstantiatedType(field.template, field.typeContext))
        field_value.parentValue = value
        field.template.createLayout(field_value, field.typeContext)
        value.members[field.name] = field_value


class StructureContextBuilder:
    def __init__(self, type_manager=None):
        self.typeManager = type_manager or globalTypeManager()
        self.context = InstantiateContext(fields=list(), links=list())

    def addField(self, name, template, context=None, align_hint=0):
        if isinstance(template, str):
            template = self.typeManager.getTemplateChecked(template)
        elif template is None:
            raise TypeError('template not found')
        self.context['fields'].append(Structure.Field(name, template, context, align_hint))

    def addLink(self, src, dst):
        self.context['links'].append(Structure.Link(src, dst))


class AbstractTypeConfigWidget(QWidget):
    descriptionChanged = pyqtSignal()

    def __init__(self, parent, template):
        QWidget.__init__(self, parent)
        self.template = template

    def initFromContext(self, context):
        pass

    def createContext(self):
        raise NotImplementedError()

    @property
    def description(self):
        return None


class OnlyEndianessConfigWidget(AbstractTypeConfigWidget):
    def __init__(self, parent, template):
        AbstractTypeConfigWidget.__init__(self, parent, template)

        self.cmbEndianess = QComboBox(self)
        self.cmbEndianess.addItem(utils.tr('Little endian'), LittleEndian)
        self.cmbEndianess.addItem(utils.tr('Big endian'), BigEndian)

        self.setLayout(QFormLayout())
        self.layout().addRow(utils.tr('Endianess:'), self.cmbEndianess)

    def initFromContext(self, context):
        self.cmbEndianess.setCurrentIndex(int(context['endianess'] == BigEndian))

    def createContext(self):
        context = InstantiateContext()
        context['endianess'] = LittleEndian if self.cmbEndianess.currentIndex() == 0 else BigEndian
        return context


class ZeroStringConfigWidget(AbstractTypeConfigWidget):
    descriptionChanged = pyqtSignal(str)

    def __init__(self, parent, template):
        AbstractTypeConfigWidget.__init__(self, parent, template)

        self.cmbEncoding = encodings.EncodingsCombo(self, 'utf-8')
        self.cmbEncoding.encodingNameChanged.connect(self._onEncodingChanged)
        self.spnLimit = QSpinBox(self)
        self.spnLimit.setMaximum(10000)
        self.spnLimit.setValue(self.spnLimit.maximum())

        self.setLayout(QFormLayout())
        self.layout().addRow(utils.tr('Encoding:'), self.cmbEncoding)
        self.layout().addRow(utils.tr('Length limit (chars):'), self.spnLimit)

    def initFromContext(self, context):
        self.cmbEncoding.encoding = context.get('encoding', 'utf-8')
        self.spnLimit.setValue(context.get('limit', 10000))

    def createContext(self):
        context = InstantiateContext()
        context['encoding'] = self.cmbEncoding.encoding
        context['limit'] = self.spnLimit.value()
        return context

    @property
    def description(self):
        return 'zero_string [{0}]'.format(self.cmbEncoding.encodingName)

    def _onEncodingChanged(self):
        self.descriptionChanged.emit(self.description)


class ZeroStringTemplate(AbstractTemplate):
    def __init__(self):
        AbstractTemplate.__init__(self, 'zero_string', dict(encoding=str, limit=int))

    def setContextDefaults(self, context):
        context.setDefaults(encoding=encodings.getCodec('utf-8'), limit=10000)
        AbstractTemplate.setContextDefaults(self, context)

    @property
    def fixedSize(self):
        return 0

    def decode(self, context):
        def_value = Value.buildValue(InstantiatedType(self, context))

        cloned_cursor = context['cursor'].clone()

        if isinstance(context['encoding'], encodings.AbstractCodec):
            encoding = context['encoding']
        else:
            encoding = encodings.getCodec(context['encoding'])
        if encoding is None:
            raise self.decodeError('no encoding {0} found'.format(context['encoding']), def_value)

        bytes_parsed = 0
        parsed_chars = list()
        with cloned_cursor.activate():
            unterminated = False
            while cloned_cursor.isAtValidPosition:
                if context['limit'] >= 0 and len(parsed_chars) >= context['limit']:
                    break

                try:
                    char_data = encoding.getCharacterData(cloned_cursor)
                except encodings.EncodingError as err:
                    raise self.decodeError('while decoding character: {0}'.format(err), def_value)

                bytes_parsed += char_data.bufferRange.size
                if char_data.unicode == '\u0000':
                    break
                parsed_chars.append(char_data.unicode)

                cloned_cursor.advance(char_data.bufferRange.size)
            else:
                unterminated = True

            def_value.bufferRange = context['cursor'].bufferRange(0, bytes_parsed)
            def_value.cachedBufferData = context['cursor'].read(0, bytes_parsed)
            if unterminated and not parsed_chars:
                raise self.decodeError(utils.tr('no enough data available'), def_value)
            def_value.decodedValue = ''.join(parsed_chars)
            if unterminated:
                def_value.decodeStatus = Value.StatusWarning
                def_value.decodeStatusText = 'no terminate zero found, stopped at the end of buffer'
            return def_value

    def createConfigWidget(self, parent):
        return ZeroStringConfigWidget(parent, self)


class FixedStringTemplate(AbstractTemplate):
    def __init__(self):
        AbstractTemplate.__init__(self, 'fixed_string', dict(size=int, encoding=str))

    def setContextDefaults(self, context):
        context.setDefaults(encoding=encodings.getCodec('utf-8'), size=0)
        AbstractTemplate.setContextDefaults(self, context)

    def decode(self, context):
        def_value = Value.buildValue(InstantiatedType(self, context))

        cloned_cursor = context['cursor'].limited(context['size'])
        if isinstance(context['encoding'], encodings.AbstractCodec):
            encoding = context['encoding']
        else:
            encoding = encodings.getCodec(context['encoding'])
        if encoding is None:
            raise self.decodeError('no encoding {0} found'.format(context['encoding']), def_value)

        decoded_chars = list()
        while cloned_cursor.position - context['cursor'].position < context['size']:
            try:
                char_data = encoding.getCharacterData(cloned_cursor)
                decoded_chars.append(char_data.unicode)
                cloned_cursor.advance(char_data.bufferRange.size)
            except encodings.EncodingError as err:
                raise self.decodeError('while decoding character: {0}'.format(err), def_value)

        def_value.bufferRange = context['cursor'].bufferRange(0, cloned_cursor.position - context['cursor'].position)
        def_value.cachedBufferData = context['cursor'].read(0, cloned_cursor.position - context['cursor'].position)
        def_value.decodedValue = ''.join(decoded_chars)
        return def_value

    def createConfigWidget(self, parent):
        return FixedStringConfigWidget(parent, self)


class FixedStringConfigWidget(AbstractTypeConfigWidget):
    descriptionChanged = pyqtSignal(str)

    def __init__(self, parent, template):
        AbstractTypeConfigWidget.__init__(self, parent, template)

        self.cmbEncoding = encodings.EncodingsCombo(self, 'utf-8')
        self.cmbEncoding.encodingNameChanged.connect(self._onEncodingChanged)
        self.spnSize = QSpinBox(self)
        self.spnSize.setMaximum(20)
        self.spnSize.setValue(self.spnSize.maximum())

        self.setLayout(QFormLayout())
        self.layout().addRow(utils.tr('Encoding:'), self.cmbEncoding)
        self.layout().addRow(utils.tr('Size (bytes):'), self.spnSize)

    def initFromContext(self, context):
        self.cmbEncoding.encoding = context.get('encoding', 'utf-8')
        self.spnSize.setValue(context.get('limit', 20))

    def createContext(self):
        context = InstantiateContext()
        context['encoding'] = self.cmbEncoding.encoding
        context['size'] = self.spnSize.value()
        return context

    @property
    def description(self):
        return 'fixed_string [{0}]'.format(self.cmbEncoding.encodingName)

    def _onEncodingChanged(self):
        self.descriptionChanged.emit(self.description)


class BooleanTemplate(AbstractTemplate):
    def __init__(self):
        AbstractTemplate.__init__(self, 'bool', {'baseType': AbstractTemplate})

    def setContextDefaults(self, context):
        context.setDefaults(baseType=globalTypeManager().getTemplate('builtins.uint8'))
        AbstractTemplate.setContextDefaults(self, context)

    def decode(self, context):
        def_value = Value.buildValue(InstantiatedType(self, context))

        try:
            undervalue = context['baseType'].decode(context)
        except DecodeError as err:
            undervalue = err.value

        def_value.bufferRange, def_value.cachedBufferData = undervalue.bufferRange, undervalue.cachedBufferData
        def_value.comment = undervalue.comment
        if undervalue.decodedValue is None:
            raise self.decodeError('base value is <none>', def_value)
        def_value.decodedValue = bool(undervalue.decodedValue)
        return def_value

    def createConfigWidget(self, parent):
        #todo
        pass


class PlatformProfile:
    """Platform profile provides typedefs for fixed-size integers that are specific for platform, as well as some
    other information (default endianess).
    """
    def __init__(self, name):
        self.name = name  # can be used as namespace name for platform-specific typedef, so should be valid ns name
        self.primitiveTypes = dict()  # typedef name for primitive type: (real type name, alignment_hint)
        self.endianess = LittleEndian


class TypesNamespace(object):
    """Groups type templates and namespaces together.
    """

    def __init__(self, name, parent_namespace):
        self.name = name
        self.parentNamespace = parent_namespace
        self.members = collections.OrderedDict()

    def enumerate(self):
        for member in self.members.values():
            yield member


class TypeManager:
    """TypeManager groups namespaces and types inside them. Root namespace (has no name, parent of all namespaces)
    cannot contain types (only namespaces).
    User code should use TypeManager methods to access template functionality.
    There are two namespaces that commonly exist in TypeManager:
        builtins: contains basic standard platform-independent templates for primitive and complex types.
        platform: contains standard platform-dependent types.
    """

    def __init__(self, profile=None):
        self.rootNamespace = TypesNamespace('', None)
        self.platformProfile = profile or self.getPlatformProfile()

    def install(self, name, template):
        """Installs type template to this type manager. Name should be fully qualified (no shortcuts like '.name'
        allowed). This limitation exist to prevent accidental installations of user types into builtins namespace.
        """
        if not name or not isinstance(template, AbstractTemplate):
            raise ValueError(utils.tr('failed to install type template'))

        name_parts = name.split('.')
        if len(name_parts) == 1:
            raise ValueError(utils.tr('type templates cannot be installed to root namespace'))

        if not all(self.isValidName(np) for np in name_parts):
            raise ValueError(utils.tr('failed to install type template: name {0} is invalid').format(name))

        ns = self._createNamespace('.'.join(name_parts[:-1]))
        if name_parts[-1] in ns.members:
            raise ValueError(utils.tr('cannot install type template {0} - name already reserved').format(name))

        ns.members[name_parts[-1]] = template
        template.typeManager = self
        template.qualifiedName = name

    def getNamespace(self, namespace_name) -> TypesNamespace:
        if not namespace_name:
            return self.rootNamespace
        current_namespace = self.rootNamespace
        for name_part in namespace_name.split('.'):
            current_namespace = current_namespace.members.get(name_part)
            if current_namespace is None or not isinstance(current_namespace, TypesNamespace):
                return None
        return current_namespace

    def getTemplate(self, type_name) -> AbstractTemplate:
        """There are three forms in which type name can be specified:
            - with fully qualified names (namespace.nested.type)
            - with leading dot - in this case type will be searched in builtins namespace (.type = builtins.type,
              .inner.type = builtins.inner.type)
            - plain type name without namespaces - same as name with leading dot, but no nesting allowed.
           Returs None if type was not found.
        """
        namespace_name, unqualified_type_name = self.splitQualifiedName(self.qualifyTypeName(type_name))
        namespace = self.getNamespace(namespace_name)
        if namespace is not None:
            template = namespace.members.get(unqualified_type_name)
            if isinstance(template, AbstractTemplate):
                return template

    def getTemplateChecked(self, type_name):
        """Same as getTemplate, but raises TemplateNotFoundError when type not found.
        """
        template = self.getTemplate(type_name)
        if template is None:
            raise TemplateNotFoundError(self.qualifyTypeName(type_name))
        return template

    def decode(self, type_name, cursor, context=None) -> Value:
        template = self.getTemplateChecked(type_name)
        context = self.prepareContext(context, template, cursor)
        return template.decode(context)

    #def write(self, type_name, cursor, value, write_method, context=None) -> None:
    #    template = self.getTemplateChecked(type_name)
    #    context = self.prepareContext(context, template, cursor)
    #    return template.write(context, value, write_method)

    @staticmethod
    def qualifyTypeName(name):
        if '.' not in name:
            return 'builtins.' + name
        elif name.startswith('.'):
            return 'builtins' + name
        return name

    @staticmethod
    def splitQualifiedName(name):
        if '.' in name:
            return name[:name.rindex('.')], name[name.rindex('.') + 1:]
        else:
            return '', name

    @staticmethod
    def isValidName(name) -> bool:
        return (isinstance(name, str) and bool(name) and name[0] in TypeManager._allowed_first_chars and
                all(c in TypeManager._allowed_chars for c in name[1:]))

    def createConfigWidget(self, parent, type_name):
        """Creates widget to configure given data type. Use AbstractDataType.createConfigWidget to create widget
        that will be initialized with instantiated type parameters.
        """
        return self.getTemplateChecked(type_name).createConfigWidget(parent)

    _allowed_first_chars = string.ascii_letters + '_'
    _allowed_chars = string.ascii_letters + string.digits + '_'

    def _createNamespace(self, namespace_name):
        current_namespace = self.rootNamespace
        for part in namespace_name.split('.'):
            if not self.isValidName(part):
                raise ValueError(utils.tr('invalid namespace name: {0}').format(part))
            if part not in current_namespace.members:
                current_namespace.members[part] = TypesNamespace(part, current_namespace)
            current_namespace = current_namespace.members[part]
            if current_namespace is None or not isinstance(current_namespace, TypesNamespace):
                raise ValueError(utils.tr('{0} is not a namespace').format(current_namespace))
        return current_namespace

    def prepareContext(self, context, template, cursor):
        """Sets some parameters for context and initializes its defaults. Use it before transferring context to
        template decode function when using template directly.
        """
        if context is None:
            context = InstantiateContext()
        context['cursor'] = cursor
        context.setDefaults(endianess=self.platformProfile.endianess)
        context['typeManager'] = self
        template.setContextDefaults(context)
        return context

    def _createIntTemplate(self, real_name, int_width, int_signed):
        def type_init(self):
            AbstractIntegerTemplate.__init__(self, real_name, int_width, int_signed)

        return type(real_name.capitalize(), (AbstractIntegerTemplate,), dict(__init__=type_init))()

    def installBuiltins(self):
        # build standard integer types (platform independent)
        _int_types_data = (
            ('int8', 1, True), ('uint8', 1, False), ('int16', 2, True), ('uint16', 2, False),
            ('int32', 4, True), ('uint32', 4, False), ('int64', 8, True), ('uint64', 8, False)
        )

        for int_type_data in _int_types_data:
            self.install('builtins.' + int_type_data[0], self._createIntTemplate(*int_type_data))

        self.install('builtins.float', FloatTemplate())
        self.install('builtins.double', DoubleTemplate())
        self.install('builtins.fixed_string', FixedStringTemplate())
        self.install('builtins.zero_string', ZeroStringTemplate())
        self.install('builtins.bool', BooleanTemplate())
        self.install('builtins.struct', Structure())

    def installPlatform(self):
        # create platform-specific typedefs for integers
        platform = self.platformProfile
        platform_prefix = (platform.name or 'platform') + '.'
        for typedef_name in platform.primitiveTypes:
            base_type = self.getTemplate(platform.primitiveTypes[typedef_name][0])
            if base_type is not None:
                real_type = self._createIntTemplate(platform.primitiveTypes[typedef_name][0], base_type._width,
                                                    base_type._signed)
                real_type.defaultAlignHint = platform.primitiveTypes[typedef_name][1]
                self.install(platform_prefix + typedef_name, real_type)

    @staticmethod
    def getPlatformProfile():
        """Creates profile of platform application being running on.
        """

        #todo: signed/unsigned chars?
        int_ds = {
            ('char', 'c_byte'),  # note that c_char can be unsigned on some platforms
            ('uchar', 'c_ubyte'),
            ('short', 'c_short'),
            ('ushort', 'c_ushort'),
            ('int', 'c_int'),
            ('uint', 'c_int'),
            ('long', 'c_long'),
            ('ulong', 'c_ulong'),
            ('longlong', 'c_longlong'),
            ('ulonglong', 'c_ulonglong')
        }

        profile = PlatformProfile('platform')
        for int_d in int_ds:
            # determine width and alignment of corresponding C type
            c_type = getattr(ctypes, int_d[1])
            int_width = ctypes.sizeof(c_type)
            int_alignment = ctypes.alignment(c_type)
            # and find fixed-width builtin int typedef should be mapped to
            real_type_name = ('u' if int_d[0].startswith('u') else '') + 'int' + str(int_width * 8)
            profile.primitiveTypes[int_d[0]] = real_type_name, int_alignment

        profile.endianess = LittleEndian if sys.byteorder == 'little' else BigEndian
        return profile


globalTypeManager = utils.createSingleton(TypeManager)
globalTypeManager().installBuiltins()
globalTypeManager().installPlatform()


class TypeChooserWidget(QWidget):
    """Allows user to choose one type from installed types. Displays tree view where all installed types are displayed
    in a tree (grouped by namespace), and additional widget provided by type where user can adjust parameters
    type will be instantiated with.
    """
    selectedTemplateChanged = pyqtSignal(object, object)  # new_type, old_type

    def __init__(self, parent, type_manager=None, show_description=True):
        QWidget.__init__(self, parent)

        self.typeManager = type_manager or globalTypeManager()
        self.typeConfigWidget = None
        self._selectedTemplate = None
        self._showDescriptionField = show_description
        self._autoDescription = True
        self._descriptionConnector = utils.SignalConnector(descriptionChanged=self._updateDescription)
        self.descriptionSeparator = None
        self.txtDescription = None
        self._descriptionLayout = None

        self.templatesModel = TypesModel(self.typeManager)
        self.templatesView = QTreeView(self)
        self.templatesView.setModel(self.templatesModel)
        self.templatesView.setSelectionBehavior(QTreeView.SelectRows)
        self.templatesView.setSelectionMode(QTreeView.SingleSelection)
        self.templatesView.selectionModel().currentChanged.connect(self._switchTemplate)
        self.templatesView.setHeaderHidden(True)
        self.templatesView.expandAll()

        if self._showDescriptionField:
            self.descriptionSeparator = QFrame()
            self.descriptionSeparator.setFrameShape(QFrame.HLine)
            self.descriptionSeparator.setFrameShadow(QFrame.Sunken)

            self.txtDescription = QLineEdit()
            self.txtDescription.textEdited.connect(self._onDescriptionTextEdited)
            self._descriptionLayout = QFormLayout()
            self._descriptionLayout.addRow(utils.tr('Description'), self.txtDescription)

        self.setLayout(QVBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().addWidget(self.templatesView)

        if self._showDescriptionField:
            self.layout().addWidget(self.descriptionSeparator)
            self.layout().addLayout(self._descriptionLayout)

    @property
    def description(self):
        return self.txtDescription.text()

    @description.setter
    def description(self, new_text):
        self.txtDescription.setText(new_text)
        self._autoDescription = False

    @property
    def showDescriptionField(self):
        return self._showDescriptionField

    def _onDescriptionTextEdited(self):
        self._autoDescription = False

    def _updateDescription(self, new_desc):
        if self._autoDescription:
            self.txtDescription.setText(new_desc)

    def _switchTemplate(self, current):
        """Called each time current template in view is changed, and updates type configuration widget"""
        # remove configuration widget of previous template, if any
        if self.typeConfigWidget is not None:
            self.layout().removeWidget(self.typeConfigWidget)
            self.typeConfigWidget.deleteLater()
            self.typeConfigWidget = None

        old_selected = self._selectedTemplate
        self._selectedTemplate = None
        self.txtDescription.clear()
        self._autoDescription = True

        template = current.data(TypesModel.TemplateRole)
        if template is not None:
            self._selectedTemplate = template
            self.typeConfigWidget = template.createConfigWidget(self)
            if self.typeConfigWidget is not None:
                self.layout().insertWidget(1, self.typeConfigWidget)

                if self._showDescriptionField:
                    if self.typeConfigWidget is not None and hasattr(self.typeConfigWidget, 'description'):
                        self.txtDescription.setText(self.typeConfigWidget.description)
                    else:
                        self.txtDescription.setText(current.data())

        if self._showDescriptionField:
            self.txtDescription.setEnabled(self._selectedTemplate is not None)
            self._descriptionConnector.target = self.typeConfigWidget

        if self._selectedTemplate is not old_selected:
            self.selectedTemplateChanged.emit(self._selectedTemplate, old_selected)

    @property
    def selectedTemplate(self):
        return self._selectedTemplate

    @selectedTemplate.setter
    def selectedTemplate(self, new_template):
        self.templatesView.setCurrentIndex(self.templatesModel.indexFromTemplate(new_template))

    @property
    def context(self):
        if self.selectedTemplate is not None:
            if self.typeConfigWidget is not None:
                return self.typeConfigWidget.createContext()
            else:
                return InstantiateContext()

    @context.setter
    def context(self, new_context):
        if self.typeConfigWidget is not None:
            self.typeConfigWidget.initFromContext(new_context)

    @property
    def instantiated(self):
        return InstantiatedType(self.selectedTemplate, self.context)

    @instantiated.setter
    def instantiated(self, inst):
        self.selectedTemplate = inst.template
        self.context = inst.context


class TypesModel(QAbstractItemModel):
    """Model represents all available types and namespaces in hierarchical structure. First level consist of namespaces
    residing in root namespace.
    """
    TemplateNameRole, TemplateRole = Qt.UserRole + 1, Qt.UserRole + 2

    def __init__(self, type_manager=None):
        QAbstractItemModel.__init__(self)
        self._internalDataCache = list()
        self._typeManager = type_manager or globalTypeManager()

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            ns = parent.internalPointer()[1]
            if not isinstance(ns, TypesNamespace):
                return 0
        else:
            ns = self._typeManager.rootNamespace
        return len(ns.members)

    def columnCount(self, parent=QModelIndex()):
        return int(not parent.isValid() or isinstance(parent.internalPointer()[1], TypesNamespace))

    def data(self, index, role=Qt.DisplayRole):
        if index.isValid():
            ns, obj = index.internalPointer()
            if isinstance(obj, TypesNamespace):
                if role == Qt.DisplayRole:
                    return obj.name
                elif role == Qt.DecorationRole:
                    return QIcon(':/main/images/edit-code.png')
            elif obj is not None:
                assert(isinstance(obj, AbstractTemplate))
                if role == Qt.DisplayRole:
                    return TypeManager.splitQualifiedName(obj.qualifiedName)[1]
                elif role == Qt.DecorationRole:
                    return QIcon(':/main/images/type.png')
                elif role == self.TemplateNameRole:
                    return obj.qualifiedName
                elif role == self.TemplateRole:
                    return obj

    def parent(self, index):
        if index.isValid():
            return self.indexFromNamespace(index.internalPointer()[0])
        return QModelIndex()

    def index(self, row, column, parent=QModelIndex()):
        """Internal data of index contains tuple (namespace, object) where :object: is object represented by index
        (TypesNamespace or AbstractDataType) and :namespace: is TypesNamespace containing this object.
        """
        ns = self._typeManager.rootNamespace if not parent.isValid() else parent.internalPointer()[1]
        if ns is not None and 0 <= row < len(ns.members) and column == 0:
            obj = list(ns.members.values())[row]
            return self._createIndex(row, column, (ns, obj))
        return QModelIndex()

    def indexFromNamespace(self, ns):
        if ns is not None and ns.parentNamespace is not None:
            parent_ns = ns.parentNamespace
            row = utils.first(index for member, index in zip(parent_ns.members.values(), itertools.count()) if member is ns)
            if row is not None:
                return self._createIndex(row, 0, (parent_ns, ns))
        return QModelIndex()

    def indexFromTemplate(self, template):
        qual_name = TypeManager.qualifyTypeName(template) if isinstance(template, str) else template.qualifiedName
        c_namespace_name, c_type_name = TypeManager.splitQualifiedName(qual_name)
        c_namespace = self._typeManager.getNamespace(c_namespace_name)
        c_namespace_index = self.indexFromNamespace(c_namespace)
        if c_namespace_index.isValid() and c_type_name in c_namespace.members:
            return self.index(list(c_namespace.members.keys()).index(c_type_name), 0, c_namespace_index)
        return QModelIndex()

    def _createIndex(self, row, column, internal_data):
        # well, we cannot just put another tuple to internalPointer of indexes: Qt internally uses this pointer
        # to compare indexes for equality, and indexes with different pointers are considered different. So we
        # must look for already created tuple with same data. This makes our code slow, but... Another reason for
        # having internal data cache is to keep tuples safe from GC.
        if internal_data in self._internalDataCache:
            internal_data = self._internalDataCache[self._internalDataCache.index(internal_data)]
        else:
            self._internalDataCache.append(internal_data)
        return self.createIndex(row, column, internal_data)
